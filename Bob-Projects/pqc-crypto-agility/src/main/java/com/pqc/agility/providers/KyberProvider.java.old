package com.pqc.agility.providers;

import com.pqc.agility.*;
import org.openquantumsafe.KeyEncapsulation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.HashMap;

/**
 * Kyber Post-Quantum KEM provider
 */
public class KyberProvider implements CryptoProvider {
    private static final Logger logger = LoggerFactory.getLogger(KyberProvider.class);
    
    private final String variant;
    private final String algorithmName;
    private final boolean available;
    private final int securityLevel;
    
    public KyberProvider(String variant) {
        this.variant = variant; // "Kyber512", "Kyber768", "Kyber1024"
        this.algorithmName = variant;
        this.securityLevel = getSecurityLevelForVariant(variant);
        this.available = checkAvailability();
    }
    
    private int getSecurityLevelForVariant(String variant) {
        return switch (variant) {
            case "Kyber512" -> 128;
            case "Kyber768" -> 192;
            case "Kyber1024" -> 256;
            default -> 128;
        };
    }
    
    private boolean checkAvailability() {
        try {
            KeyEncapsulation kem = new KeyEncapsulation(variant);
            kem.dispose();
            return true;
        } catch (Exception e) {
            logger.error("Kyber provider {} not available", variant, e);
            return false;
        }
    }
    
    @Override
    public String getAlgorithmName() {
        return algorithmName;
    }
    
    @Override
    public ProviderType getProviderType() {
        return ProviderType.POST_QUANTUM;
    }
    
    @Override
    public int getSecurityLevel() {
        return securityLevel;
    }
    
    @Override
    public KeyPair generateKeyPair() throws CryptoException {
        try {
            KeyEncapsulation kem = new KeyEncapsulation(variant);
            byte[] publicKey = kem.export_public_key();
            byte[] privateKey = kem.export_secret_key();
            kem.dispose();
            
            return new KeyPair(
                new KyberPublicKey(publicKey),
                new KyberPrivateKey(privateKey)
            );
        } catch (Exception e) {
            throw new CryptoException("Failed to generate Kyber key pair", e);
        }
    }
    
    @Override
    public byte[] encrypt(byte[] data, PublicKey publicKey) throws CryptoException {
        // Kyber is a KEM, not encryption. Use encapsulate + symmetric encryption
        throw new CryptoException("Kyber is a KEM - use encapsulate() instead of encrypt()");
    }
    
    @Override
    public byte[] decrypt(byte[] encryptedData, PrivateKey privateKey) throws CryptoException {
        throw new CryptoException("Kyber is a KEM - use decapsulate() instead of decrypt()");
    }
    
    @Override
    public byte[] sign(byte[] data, PrivateKey privateKey) throws CryptoException {
        throw new CryptoException("Kyber is a KEM - use Dilithium for signatures");
    }
    
    @Override
    public boolean verify(byte[] data, byte[] signature, PublicKey publicKey) throws CryptoException {
        throw new CryptoException("Kyber is a KEM - use Dilithium for signatures");
    }
    
    @Override
    public EncapsulationResult encapsulate(PublicKey publicKey) throws CryptoException {
        try {
            if (!(publicKey instanceof KyberPublicKey)) {
                throw new CryptoException("Invalid public key type for Kyber");
            }
            
            KyberPublicKey kyberPubKey = (KyberPublicKey) publicKey;
            KeyEncapsulation kem = new KeyEncapsulation(variant, kyberPubKey.getEncoded());
            
            KeyEncapsulation.Ciphertext ciphertext = kem.encap_secret();
            byte[] sharedSecret = ciphertext.getShared_secret();
            byte[] ciphertextBytes = ciphertext.getCiphertext();
            
            kem.dispose();
            
            return new EncapsulationResult(ciphertextBytes, sharedSecret);
        } catch (Exception e) {
            throw new CryptoException("Kyber encapsulation failed", e);
        }
    }
    
    @Override
    public byte[] decapsulate(byte[] ciphertext, PrivateKey privateKey) throws CryptoException {
        try {
            if (!(privateKey instanceof KyberPrivateKey)) {
                throw new CryptoException("Invalid private key type for Kyber");
            }
            
            KyberPrivateKey kyberPrivKey = (KyberPrivateKey) privateKey;
            KeyEncapsulation kem = new KeyEncapsulation(variant, kyberPrivKey.getEncoded());
            
            byte[] sharedSecret = kem.decap_secret(ciphertext);
            kem.dispose();
            
            return sharedSecret;
        } catch (Exception e) {
            throw new CryptoException("Kyber decapsulation failed", e);
        }
    }
    
    @Override
    public boolean isQuantumSafe() {
        return true;
    }
    
    @Override
    public boolean supportsKEM() {
        return true;
    }
    
    @Override
    public PerformanceMetrics getPerformanceMetrics() {
        // Approximate metrics for Kyber variants
        int keyGenTime = switch (variant) {
            case "Kyber512" -> 50;
            case "Kyber768" -> 80;
            case "Kyber1024" -> 120;
            default -> 80;
        };
        
        int publicKeySize = switch (variant) {
            case "Kyber512" -> 800;
            case "Kyber768" -> 1184;
            case "Kyber1024" -> 1568;
            default -> 1184;
        };
        
        int privateKeySize = switch (variant) {
            case "Kyber512" -> 1632;
            case "Kyber768" -> 2400;
            case "Kyber1024" -> 3168;
            default -> 2400;
        };
        
        int ciphertextSize = switch (variant) {
            case "Kyber512" -> 768;
            case "Kyber768" -> 1088;
            case "Kyber1024" -> 1568;
            default -> 1088;
        };
        
        return new PerformanceMetrics.Builder()
            .keyGenTimeMs(keyGenTime)
            .encryptTimeMs(5)
            .decryptTimeMs(5)
            .publicKeySize(publicKeySize)
            .privateKeySize(privateKeySize)
            .ciphertextSize(ciphertextSize)
            .build();
    }
    
    @Override
    public boolean isAvailable() {
        return available;
    }
    
    @Override
    public ProviderMetadata getMetadata() {
        return new ProviderMetadata.Builder()
            .name(algorithmName)
            .version("1.0")
            .description("Kyber Post-Quantum KEM - NIST PQC standardized")
            .type(ProviderType.POST_QUANTUM)
            .securityLevel(securityLevel)
            .quantumSafe(true)
            .supportsKEM(true)
            .supportsSignatures(false)
            .additionalInfo(new HashMap<>() {{
                put("variant", variant);
                put("standard", "NIST FIPS 203");
                put("type", "Lattice-based KEM");
            }})
            .build();
    }
    
    // Inner classes for Kyber keys
    private static class KyberPublicKey implements PublicKey {
        private final byte[] keyBytes;
        
        public KyberPublicKey(byte[] keyBytes) {
            this.keyBytes = keyBytes;
        }
        
        @Override
        public String getAlgorithm() {
            return "Kyber";
        }
        
        @Override
        public String getFormat() {
            return "RAW";
        }
        
        @Override
        public byte[] getEncoded() {
            return keyBytes;
        }
    }
    
    private static class KyberPrivateKey implements PrivateKey {
        private final byte[] keyBytes;
        
        public KyberPrivateKey(byte[] keyBytes) {
            this.keyBytes = keyBytes;
        }
        
        @Override
        public String getAlgorithm() {
            return "Kyber";
        }
        
        @Override
        public String getFormat() {
            return "RAW";
        }
        
        @Override
        public byte[] getEncoded() {
            return keyBytes;
        }
        
        @Override
        public void destroy() {
            Arrays.fill(keyBytes, (byte) 0);
        }
        
        @Override
        public boolean isDestroyed() {
            return false;
        }
    }
}

// Made with Bob
